/**
 * Web-compatible type definitions extracted from test/proto.d.ts
 * 
 * This file contains ONLY pure type definitions (interfaces and enums).
 * All class declarations and native dependencies have been removed.
 * 
 * Generated by extract_types.py - DO NOT EDIT MANUALLY
 * To regenerate: cd web/test && python3 extract_types.py > proto-types.d.ts
 */

import Long from 'long';

/**
 */

export namespace test {
  export const enum Enum {
    VALUE_0 = 0,
    VALUE_1 = 1,
    /** Unrecognized value */
    $UNRECOGNIZED_VALUE = 0xffffffffff
  }

  /**
   * Test
   * multiline
   * comment
   */

  /** Interface for creating OtherMessage instances */
  export interface IOtherMessage {
    value?: string;
  }

  /**
   * Test comment
   * another line
   */

  /** Interface for creating Message instances */
  export interface IMessage {
    int32?: number;
    int64?: Long;
    uint32?: number;
    uint64?: Long;
    sint32?: number;
    sint64?: Long;
    fixed32?: number;
    fixed64?: Long;
    sfixed32?: number;
    sfixed64?: Long;
    float?: number;
    double?: number;
    bool?: boolean;
    string?: string;
    bytes?: Uint8Array;
    enum?: test.Enum;
    selfMessage?: test.IMessage;
    otherMessage?: test.IOtherMessage;
  }


  /** Interface for creating RepeatedMessage instances */
  export interface IRepeatedMessage {
    int32?: readonly number[];
    int64?: readonly Long[];
    uint32?: readonly number[];
    uint64?: readonly Long[];
    sint32?: readonly number[];
    sint64?: readonly Long[];
    fixed32?: readonly number[];
    fixed64?: readonly Long[];
    sfixed32?: readonly number[];
    sfixed64?: readonly Long[];
    float?: readonly number[];
    double?: readonly number[];
    bool?: readonly boolean[];
    string?: readonly string[];
    bytes?: readonly Uint8Array[];
    enum?: readonly test.Enum[];
    selfMessage?: readonly test.IRepeatedMessage[];
    otherMessage?: readonly test.IOtherMessage[];
  }


  /** Interface for creating ParentMessage instances */
  export interface IParentMessage {
    childMessage?: test.ParentMessage.IChildMessage;
    childEnum?: test.ParentMessage.ChildEnum;
  }

  export namespace ParentMessage {
    /** Comment for child enum */
    export const enum ChildEnum {
      /** Comment for value 0 */
      VALUE_0 = 0,
      /** Comment for value 1 */
      VALUE_1 = 1,
      /** Unrecognized value */
      $UNRECOGNIZED_VALUE = 0xffffffffff
    }


    /** Interface for creating ChildMessage instances */
    export interface IChildMessage {
      value?: string;
    }
  }


  /** Interface for creating OneOfMessage instances */
  export interface IOneOfMessage {
    string0?: string;
    string1?: string;
    message0?: test.IOtherMessage;
    message1?: test.IOtherMessage;
    bytes0?: Uint8Array;
    bytes1?: Uint8Array;
  }


  /** Interface for creating OldMessage instances */
  export interface IOldMessage {
    oldValue?: string;
  }


  /** Interface for creating NewMessage instances */
  export interface INewMessage {
    oldValue?: string;
    newValue?: string;
  }


  /** Interface for creating OldEnumMessage instances */
  export interface IOldEnumMessage {
    value?: test.OldEnumMessage.OldEnum;
    repeatedValue?: readonly test.OldEnumMessage.OldEnum[];
    mappedValue?: ReadonlyMap<string, test.OldEnumMessage.OldEnum>;
  }

  export namespace OldEnumMessage {
    export const enum OldEnum {
      VALUE_0 = 0,
      VALUE_1 = 1,
      /** Unrecognized value */
      $UNRECOGNIZED_VALUE = 0xffffffffff
    }
  }


  /** Interface for creating NewEnumMessage instances */
  export interface INewEnumMessage {
    value?: test.NewEnumMessage.NewEnum;
    repeatedValue?: readonly test.NewEnumMessage.NewEnum[];
    mappedValue?: ReadonlyMap<string, test.NewEnumMessage.NewEnum>;
  }

  export namespace NewEnumMessage {
    export const enum NewEnum {
      VALUE_0 = 0,
      VALUE_1 = 1,
      VALUE_2 = 200,
      VALUE_3 = 300,
      /** Unrecognized value */
      $UNRECOGNIZED_VALUE = 0xffffffffff
    }
  }


  /** Interface for creating MapMessage instances */
  export interface IMapMessage {
    stringToString?: ReadonlyMap<string, string>;
    stringToNumber?: ReadonlyMap<string, number>;
    stringToSignedLong?: ReadonlyMap<string, Long>;
    stringToUnsignedLong?: ReadonlyMap<string, Long>;
    stringToDouble?: ReadonlyMap<string, number>;
    stringToMessage?: ReadonlyMap<string, test.IOtherMessage>;
    intToString?: ReadonlyMap<number, string>;
    longToString?: ReadonlyMap<Long, string>;
  }


  /** Interface for creating ExternalMessages instances */
  export interface IExternalMessages {
    otherMessage?: test3.IMessage3;
  }
}
import __test__ = test;

export namespace test3 {

  /** Interface for creating Message3 instances */
  export interface IMessage3 {
    value?: string;
  }
}
import __test3__ = test3;

export namespace test2 {

  /** Interface for creating Message2 instances */
  export interface IMessage2 {
    value?: string;
  }
}
import __test2__ = test2;

export namespace package_with_underscores {
  export const enum Enum_With_Underscores {
    ENUM_VALUE_0 = 0,
    ENUM_VALUE_1 = 1,
    E2NUM_VALUE_WITH_NUMBER = 2,
    /** Unrecognized value */
    $UNRECOGNIZED_VALUE = 0xffffffffff
  }


  /** Interface for creating Message_With_Underscores instances */
  export interface IMessage_With_Underscores {
    fieldUnderscore?: number;
    fieldUnderscoreAgain?: number;
    enumValue?: package_with_underscores.Enum_With_Underscores;
    messageValue?: package_with_underscores.IMessage_With_Underscores;
  }


  /** Interface for creating M3ssage1WithNumb3r2 instances */
  export interface IM3ssage1WithNumb3r2 {
    fie1ld?: number;
    field2?: number;
    field3?: number;
    a4Fiel4d?: number;
    a5aFiel5d?: number;
    enum?: package_with_underscores.Enum_With_Underscores;
  }
}
import __package_with_underscores__ = package_with_underscores;

